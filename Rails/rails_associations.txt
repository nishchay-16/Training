                                                    RAILS ASSOCIATIONS

An association is a connection between two Active Record models. 
We need associations between models Because they make common operations simpler and easier in your code.
These associations help in organizing and querying related data efficiently. 

For example, consider a simple Rails application that includes a model for authors and a model for books. Each author can have many books.
With Active Record associations, we can streamline these - and other - operations by declaratively telling Rails that there is a connection between the two models. 
Here's the code for setting up authors and books:

class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end



Here are the key advantages of using associations in Rails:
1) Simplified Data Retrieval:->
    Associations provide methods to easily retrieve related records. For example, with has_many and belongs_to, you can access related objects directly without complex queries.

2) Automatic Joins and Queries:->
    Rails handles database joins and complex queries automatically, saving you from writing raw SQL and ensuring efficient data retrieval.

3) Data Integrity:->
    Associations help maintain data integrity by setting constraints and automatic actions (e.g., dependent: :destroy) that ensure related records are handled properly when a parent record is modified or deleted.

4) Enhanced Readability:->
    Code that uses associations is often more readable and expressive. The relationships between models are clear, making the code easier to understand and maintain.

5) Reduced Boilerplate Code:->
    Associations reduce the amount of boilerplate code needed for managing relationships and performing common operations, leading to cleaner and more concise code.

6) Automatic Foreign Key Management:->
    Rails manages foreign keys and validates relationships, helping to avoid issues related to orphaned records or incorrect foreign key values.

7) Convenient Query Methods:->
    Associations provide built-in query methods that simplify searching and filtering related data, such as where, joins, and includes.

8) Support for Nested Attributes:->
    Associations enable nested attributes, allowing you to create or update associated records in a single operation, which is useful for forms with multiple models.

9) Data Caching:->
    Rails can cache associated records to improve performance, especially when using methods like includes to eager-load related records.

10) Validation Integration:->
    Associations can be used in conjunction with validations to enforce rules about relationships, ensuring that related records are present and valid.




                                                ===> TYPES OF ASSOCIATIONS <===

1) belongs_to -> 
A belongs_to association sets up a connection with another model, such that each instance of the declaring model "belongs to" one instance of the other model. 

Example:
class Book < ApplicationRecord
  belongs_to :author
end


2) has_one -> 
A has_one association indicates that one other model has a reference to this model. That model can be fetched through this association.

Example:
class User < ApplicationRecord
  has_one :account
end


3) has_many -> 
A has_many association is similar to has_one, but indicates a one-to-many connection with another model
This association indicates that each instance of the model has zero or more instances of another model. 

Example:
class Author < ApplicationRecord
  has_many :books
end


4) has_many :through -> 
A has_many :through association is often used to set up a many-to-many connection with another model. 
This association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model. 

Example:
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end


5) has_one :through -> 
A has_one :through association sets up a one-to-one connection with another model. 
This association indicates that the declaring model can be matched with one instance of another model by proceeding through a third model.

Example:
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end


6) has_and_belongs_to_many ->
A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model. 
This association indicates that each instance of the declaring model refers to zero or more instances of another model.

Example:
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end




                                ====>     TIPS , TRICKS & WARNINGS (for effecient use of association in rails)    <====

1) Controlling caching ->
All of the association methods are built around caching, which keeps the result of the most recent query available for further operations. 
The cache is even shared across methods:-

author.books.load                  # retrieves books from the database
author.books.size                  # uses the cached copy of books
author.books.empty?                # uses the cached copy of books
author.books.reload.empty?         # discards the cached copy of books and goes back to the database


2) Avoiding name collisions -> 
We are not free to use just any name for your associations. 
Because creating an association adds a method with that name to the model, it is a bad idea to give an association a name that is already used for an instance method of ActiveRecord::Base. 
The association method would override the base method and break things. 
For instance, attributes or connection are bad names for associations.


3) Updating the schema ->
Associations are extremely useful, but they are not magic. You are responsible for maintaining your database schema to match your associations.
   -> Creating Foreign Keys for belongs_to Associations
        class Book < ApplicationRecord
          belongs_to :author
        end

        class AddAuthorToBooks < ActiveRecord::Migration[7.1]
          def change
            add_reference :books, :author
          end
        end

   -> Creating Join Tables for has_and_belongs_to_many Associations
        class Assembly < ApplicationRecord
          has_and_belongs_to_many :parts
        end

        class Part < ApplicationRecord
          has_and_belongs_to_many :assemblies
        end

        class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.1]
          def change
            create_join_table :assemblies, :parts do |t|
              t.index :assembly_id
              t.index :part_id
            end
          end
        end


4) Controlling association scope ->
By default, associations look for objects only within the current module's scope. 
This can be important when you declare Active Record models within a module. 
For example:
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end


5) Bi-directional associations ->
It's normal for associations to work in two directions, requiring declaration on two different models:
Example:
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
Active Record will attempt to automatically identify that these two models share a bi-directional association based on the association name.


IMPORTANT => For belongs_to associations you need to create foreign keys, and for has_and_belongs_to_many associations you need to create the appropriate join table.




                                      ====> Detailed Association Reference <====

1) belongs_to Association Reference ->                    

    a) Methods Added by belongs_to ->

          * association ->
            The association method returns the associated object, if any. If no associated object is found, it returns nil.
                Example:
                  3.3.0 :031 > author = book.author
                  Author Load (0.4ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 10], ["LIMIT", 1]]
                  => 
                  #<Author:0x0000000128fd3ad0

                  3.3.0 :037 > author = book.reload_author
                  Author Load (0.8ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 10], ["LIMIT", 1]]
                  => 
                  #<Author:0x0000000128fd8350

                  3.3.0 :041 > book.reset_author
                  => false 

          * association=(associate) ->
            The association= method assigns an associated object to this object. 
            Behind the scenes, this means extracting the primary key from the associated object and setting this object's foreign key to the same value.
                Example:
                  3.3.0 :039 > book.author = author
                  => 
                  #<Author:0x0000000128fd8350

          * build_association(attributes = {}) ->
            The build_association method returns a new object of the associated type. 
            This object will be instantiated from the passed attributes, and the link through this object's foreign key will be set, but the associated object will not yet be saved.
                Example:
                  3.3.0 :044 > author =  book.build_author(author_name: "HC Verma" , nationality: "Indian")
                  => #<Author:0x000000011dd1c810 id: nil, author_name: "HC Verma", nationality: "Indian", created_at: nil, updated_at: nil> 

          * create_association(attributes = {}) ->
            The create_association method returns a new object of the associated type. 
            This object will be instantiated from the passed attributes, the link through this object's foreign key will be set, 
            and, once it passes all of the validations specified on the associated model, the associated object will be saved.
                Example:
                  3.3.0 :058 > author =  book.create_author(author_name:"MS chauhan", nationality: "Indian")
                  TRANSACTION (0.6ms)  BEGIN
                  Author Create (3.4ms)  INSERT INTO "authors" ("author_name", "nationality", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["author_name", "MS chauhan"], ["nationality", "Indian"], ["created_at", "2024-07-25 10:23:50.376919"], ["updated_at", "2024-07-25 10:23:50.376919"]]
                  TRANSACTION (0.9ms)  COMMIT
                  => 
                  #<Author:0x000000012c1df790

          * create_association!(attributes = {}) -> 
            Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid.

          * association_changed? -> 
            The association_changed? method returns true if a new associated object has been assigned and the foreign key will be updated in the next save.
                Example:
                  3.3.0 :059 > book.author_changed?
                   => true 
                  3.3.0 :060 > book.save!
                    TRANSACTION (0.2ms)  BEGIN
                    Book Update (4.2ms)  UPDATE "books" SET "updated_at" = $1, "author_id" = $2 WHERE "books"."id" = $3  [["updated_at", "2024-07-25 10:27:46.230403"], ["author_id", 12], ["id", 2]]
                    TRANSACTION (1.5ms)  COMMIT
                   => true 
                  3.3.0 :061 > book.author_changed?
                   => false 

          * association_previously_changed? ->
            The association_previously_changed? method returns true if the previous save updated the association to reference a new associate object.
                Example:
                  3.3.0 :062 > book.author_previously_changed?
                   => true 


    b) Options for belongs_to

          * :autosave ->
            Automatically saves the associated records when the parent record is saved.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, autosave: true
                  end
            If you create or update a Book instance and modify its associated Author, the Author will be saved automatically.

          * :class_name ->
            Specifies the class name of the association, if it is not the default.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :writer, class_name: 'Author'
                  end
            Here, Book belongs to Author, but we use writer as the association name. :class_name tells Rails to use the Author model for this association.

          * :counter_cache ->
             Automatically maintains a count of the number of associated records in the parent record’s table.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, counter_cache: true
                  end
            If you add books_count to the authors table, Rails will keep this count updated whenever books are added or removed.

          * :default ->
            Provides a default value for the association, used when the association is not explicitly set.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, default: -> { Author.first }
                  end
            If no author is specified, Rails will assign the first Author record as the default.

          * :dependent ->
            Specifies what should happen to associated records when the parent record is destroyed.
                Example:
                  class Author < ApplicationRecord
                    has_many :books, dependent: :destroy
                  end
            If an Author is destroyed, all associated Books will also be destroyed.

          * :ensuring_owner_was ->
            Specifies an instance method to be called on the owner. 
            The method must return true in order for the associated records to be deleted in a background job.
            
          * :foreign_key ->
            Specifies the foreign key column in the associated table.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, foreign_key: 'writer_id'
                  end
                  class Author < ApplicationRecord                    
                    has_many :books, foreign_key: 'writer_id'
                  end
            The Book model uses writer_id instead of the default author_id to refer to Author.                    

          * :foreign_type ->
            Used with polymorphic associations to specify the type column.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :owner, polymorphic: true, foreign_type: 'owner_type'
                  end
            Here, owner_type is the column that stores the type of the polymorphic association.                   

          * :primary_key ->
            Specifies the primary key column in the associated table.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, primary_key: 'uuid'
                  end
                  class Author < ApplicationRecord                    
                    self.primary_key = 'uuid'
                  end
            If Author uses uuid as its primary key instead of the default id, this option is used.                    

          * :inverse_of ->
            Specifies the inverse association to avoid redundant database queries and ensure proper object relationships.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, inverse_of: :books
                  end
                  class Author < ApplicationRecord
                    has_many :books, inverse_of: :author
                  end
              This ensures that Rails correctly handles bi-directional associations.

          * :optional ->
            Allows the association to be optional, meaning the parent record can exist without the associated record
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, optional: true
                  end
            A Book can be created without specifying an Author.

          * :polymorphic ->
            Allows the association to refer to more than one model type.
                Example:
                  class Comment < ApplicationRecord
                    belongs_to :commentable, polymorphic: true
                  end
                  class Book < ApplicationRecord
                    has_many :comments, as: :commentable
                  end
                  class Author < ApplicationRecord
                    has_many :comments, as: :commentable
                  end
            A Comment can belong to either a Book or an Author.

          * :required ->
             Ensures that the association is required and cannot be nil
                Example:
                  class Book < ApplicationRecord
                      belongs_to :author, required: true
                  end
              A Book must have an associated Author and cannot be saved without one.

          * :strict_loading ->
            Ensures that associated records are always loaded when accessed, helping to prevent N+1 query problems. 
                  Example:
                    class Book < ApplicationRecord
                      belongs_to :author, strict_loading: true
                    end
            When accessing @book.author, Rails will ensure that the author is loaded immediately.

          * :touch ->
            Updates the timestamp of the associated record whenever the parent record is updated.
                  Example:
                    class Book < ApplicationRecord
                      belongs_to :author, touch: true
                    end
            Whenever a Book is updated, the updated_at timestamp of its Author will also be updated.

          * :validate ->
            Specifies whether the associated record should be validated before saving the parent record.
                  Example:
                    class Book < ApplicationRecord
                      belongs_to :author, validate: true
                    end 
            When saving a Book, Rails will also validate the associated Author.


    c) Scopes for belongs_to
      There may be times when you wish to customize the query used by belongs_to. Such customizations can be achieved via a scope block

      * where ->
        The where method lets you specify the conditions that the associated object must meet.
      * includes ->
        You can use the includes method to specify second-order associations that should be eager-loaded when this association is used.
      * readonly -> 
        If you use readonly, then the associated object will be read-only when retrieved via the association.
      * select -> 
        The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.
 


2) has_one Association Reference ->
  The has_one association creates a one-to-one match with another model. 
  In database terms, this association says that the other class contains the foreign key. 
  If this class contains the foreign key, then we should use belongs_to instead.

    a) Methods Added by has_one 

      * association -> 
        The association method returns the associated object, if any. If no associated object is found, it returns nil.
        Example:
          3.3.0 :001 > supplier = MyApplication::Business::Supplier.find_by(id: 1)
          3.3.0 :009 > account = supplier.account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
          ... 
          3.3.0 :010 > account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
           id: 1,
           supplier_id: 1,
           account_number: "1234567890",
           created_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00,
           updated_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00> 

      * association=(associate) -> 
        The association= method assigns an associated object to this object. 
        Behind the scenes, this means extracting the primary key from this object and setting the associated object's foreign key to the same value.
        Example:
          3.3.0 :011 > supplier = MyApplication::Business::Supplier.find_by(id: 1)
          3.3.0 :012 > supplier.account = account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
          ... 
          3.3.0 :013 > account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
           id: 1,
           supplier_id: 1,
           account_number: "1234567890",
           created_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00,
           updated_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00> 

      * build_association(attributes = {}) -> 
        The build_association method returns a new object of the associated type. 
        This object will be instantiated from the passed attributes, and the link through its foreign key will be set, but the associated object will not yet be saved.
        Example:
          3.3.0 :017 > supplier = MyApplication::Business::Supplier.new(name: "Naman dua")
           => #<MyApplication::Business::Supplier:0x000000011f10ec60 id: nil, name: "Naman dua", created_at: nil, updated_at: nil> 
          3.3.0 :018 > account = supplier.build_account(account_number: "624752869698")
           => #<MyApplication::Billing::Account:0x000000011f0830c0 id: nil, supplier_id: nil, account_number: "624752869698", created_at: nil, updated_at: ... 

      * create_association(attributes = {}) -> 
        The create_association method returns a new object of the associated type. 
        This object will be instantiated from the passed attributes, the link through its foreign key will be set, and, 
        once it passes all of the validations specified on the associated model, the associated object will be saved.
        Example:
         => #<MyApplication::Billing::Account:0x000000011f0830c0 id: nil, supplier_id: nil, account_number: "624752869698", created_at: nil, updated_at: ... 
          3.3.0 :020 > account = supplier.create_account(account_number: "624752869698")
          (irb):20:in `<main>': You cannot call create unless the parent is saved (ActiveRecord::RecordNotSaved)
          3.3.0 :021 > supplier.save!         
            TRANSACTION (0.6ms)  BEGIN
            MyApplication::Business::Supplier Create (7.9ms)  INSERT INTO "suppliers" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"  [["name", "Naman dua"], ["created_at", "2024-07-26 06:00:54.564481"], ["updated_at", "2024-07-26 06:00:54.564481"]]
            MyApplication::Billing::Account Create (1.6ms)  INSERT INTO "accounts" ("supplier_id", "account_number", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["supplier_id", 2], ["account_number", "624752869698"], ["created_at", "2024-07-26 06:00:54.575831"], ["updated_at", "2024-07-26 06:00:54.575831"]]
            TRANSACTION (1.1ms)  COMMIT
           => true 

      * create_association!(attributes = {}) ->
        Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid.

      * reload_association ->
        If the associated object has already been retrieved from the database for this object, the cached version will be returned
        Example:
          3.3.0 :023 > account = supplier.reload_account
           MyApplication::Billing::Account Load (0.6ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."supplier_id" = $1 LIMIT $2  [["supplier_id", 2], ["LIMIT", 1]]
           => 
          #<MyApplication::Billing::Account:0x000000011f0c99d0
          ... 

      * reset_association ->
        To unload the cached version of the associated object—forcing the next access, if any, to query it from the database—call #reset_association on the parent object.
        Example:
          3.3.0 :024 > supplier.reset_account
           => nil


    b) Options for has_one

      * :as -> 
        Allows the association to be polymorphic. Use this option to set up polymorphic associations where one model can be associated with multiple other models.
        Example:
          class Comment < ApplicationRecord
            belongs_to :commentable, polymorphic: true
          end
          class Supplier < ApplicationRecord
            has_one :comment, as: :commentable
          end

          3.3.0 :001 > supplier = MyApplication::Business::Supplier.find(1)
          3.3.0 :002 > supplier.create_comment(content: "This is a comment")
            MyApplication::Business::Supplier Load (0.6ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
            MyApplication::Business::Comment Load (1.4ms)  SELECT "comments".* FROM "comments" WHERE "comments"."commentable_id" = $1 AND "comments"."commentable_type" = $2 LIMIT $3  [["commentable_id", 1], ["commentable_type", "MyApplication::Business::Supplier"], ["LIMIT", 1]]
            TRANSACTION (0.1ms)  BEGIN
            MyApplication::Business::Comment Create (1.6ms)  INSERT INTO "comments" ("content", "commentable_type", "commentable_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["content", "This is a comment"], ["commentable_type", "MyApplication::Business::Supplier"], ["commentable_id", 1], ["created_at", "2024-07-26 06:42:25.035439"], ["updated_at", "2024-07-26 06:42:25.035439"]]
            TRANSACTION (1.1ms)  COMMIT
             => 
          #<MyApplication::Business::Comment:0x0000000120884ac0
           id: 1,
           content: "This is a comment",
           commentable_type: "MyApplication::Business::Supplier",
           commentable_id: 1,
           created_at: Fri, 26 Jul 2024 06:42:25.035439000 UTC +00:00,
           updated_at: Fri, 26 Jul 2024 06:42:25.035439000 UTC +00:00> 
  

      * :autosave -> 
        Determines whether the associated record should be automatically saved when the parent record is saved.
          Example:
          class Supplier < ApplicationRecord
            belongs_to :supplier,
              class_name: "MyApplication::Billing::Account"
          end
            3.3.0 :023 > supplier = MyApplication::Business::Supplier.new(name: "Vaibhav")
             => #<MyApplication::Business::Supplier:0x000000012131c5a0 id: nil, name: "Vaibhav", created_at: nil, updated_at: nil> 
            3.3.0 :024 > supplier.build_account(account_number: "1234567890")
            3.3.0 :025 > supplier.save
              TRANSACTION (0.7ms)  BEGIN
              MyApplication::Business::Supplier Create (4.7ms)  INSERT INTO "suppliers" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"  [["name", "Vaibhav"], ["created_at", "2024-07-26 06:50:23.197746"], ["updated_at", "2024-07-26 06:50:23.197746"]]
              MyApplication::Billing::Account Create (2.2ms)  INSERT INTO "accounts" ("supplier_id", "account_number", "created_at", "updated_at", "accountable_type", "accountable_id") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"  [["supplier_id", 3], ["account_number", "1234567890"], ["created_at", "2024-07-26 06:50:23.205914"], ["updated_at", "2024-07-26 06:50:23.205914"], ["accountable_type", nil], ["accountable_id", nil]]
              TRANSACTION (0.5ms)  COMMIT
             => true 

      * :class_name -> 
        Specifies the class name of the associated model if it's different from the default inferred class name.
          Example:
            class Supplier < ApplicationRecord
              belongs_to :supplier,
                class_name: "MyApplication::Billing::Account"
            end

      * :dependent -> 
        Specifies what should happen to the associated record when the parent record is destroyed.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, dependent: :destroy,
                class_name: "MyApplication::Billing::Account"
            end
            3.3.0 :027 > supplier = MyApplication::Business::Supplier.find_by(name: "Vaibhav")
             MyApplication::Business::Supplier Load (0.6ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."name" = $1 LIMIT $2  [["name", "Vaibhav"], ["LIMIT", 1]]
            => 
           #<MyApplication::Business::Supplier:0x0000000120b406d8
           ... 
           3.3.0 :028 > supplier.destroy
             TRANSACTION (0.4ms)  BEGIN
             MyApplication::Billing::Account Load (0.5ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."supplier_id" = $1 LIMIT $2  [["supplier_id", 3], ["LIMIT", 1]]
             MyApplication::Billing::Account Destroy (3.6ms)  DELETE FROM "accounts" WHERE "accounts"."id" = $1  [["id", 3]]
             MyApplication::Business::Supplier Destroy (0.9ms)  DELETE FROM "suppliers" WHERE "suppliers"."id" = $1  [["id", 3]]
             TRANSACTION (0.5ms)  COMMIT
            => 
           #<MyApplication::Business::Supplier:0x0000000120b406d8
            id: 3,
            name: "Vaibhav",
            created_at: Fri, 26 Jul 2024 06:50:23.197746000 UTC +00:00,
            updated_at: Fri, 26 Jul 2024 06:50:23.197746000 UTC +00:00> 
           3.3.0 :029 > 



      * :disable_joins -> 
        Disables automatic joins in queries for this association.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, disable_joins: true,
                class_name: "MyApplication::Billing::Account"
            end
            3.3.0 :029 > MyApplication::Business::Supplier.joins(:account)   #(working because disable_joins: true)
             MyApplication::Business::Supplier Load (2.5ms)  SELECT "suppliers".* FROM "suppliers" INNER JOIN "accounts" ON "accounts"."supplier_id" = "suppliers"."id" /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
            => 
           [#<MyApplication::Business::Supplier:0x0000000121378d50
             id: 1,
             name: "Paarth Arora",
             created_at: Thu, 25 Jul 2024 09:02:49.323378000 UTC +00:00,
             updated_at: Thu, 25 Jul 2024 09:02:49.323378000 UTC +00:00>,
            #<MyApplication::Business::Supplier:0x0000000121378c10
             id: 2,
             name: "Naman dua",
             created_at: Fri, 26 Jul 2024 06:00:54.564481000 UTC +00:00,
             updated_at: Fri, 26 Jul 2024 06:00:54.564481000 UTC +00:00>] 


      * :ensuring_owner_was -> 
        Ensures that the owner record was not destroyed before saving the associated record.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, ensuring_owner_was: true,,
                class_name: "MyApplication::Billing::Account"
            end
        
      * :foreign_key -> 
        Specifies a custom foreign key for the association.
          Example:  
            class Supplier < ApplicationRecord
              has_one :account, foreign_key: "supplier_id",
                class_name: "MyApplication::Billing::Account"
            end
          3.3.0 :038 > supplier = MyApplication::Business::Supplier.find_by(name: "Naman dua")
             MyApplication::Business::Supplier Load (0.5ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."name" = $1 LIMIT $2  [["name", "Naman dua"], ["LIMIT", 1]]
            => 
           #<MyApplication::Business::Supplier:0x00000001208ea320
           ... 
           3.3.0 :039 > supplier.create_account(account_number: "1234567890")
             TRANSACTION (0.2ms)  BEGIN
             MyApplication::Business::Supplier Load (0.4ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
             MyApplication::Billing::Account Create (2.4ms)  INSERT INTO "accounts" ("supplier_id", "account_number", "created_at", "updated_at", "accountable_type", "accountable_id") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"  [["supplier_id", 2], ["account_number", "1234567890"], ["created_at", "2024-07-26 07:19:37.694900"], ["updated_at", "2024-07-26 07:19:37.694900"], ["accountable_type", nil], ["accountable_id", nil]]
             TRANSACTION (1.3ms)  COMMIT
             MyApplication::Billing::Account Load (0.3ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."supplier_id" = $1 LIMIT $2  [["supplier_id", 2], ["LIMIT", 1]]

      * :inverse_of -> 
        Specifies the inverse association to ensure proper loading and consistency.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, inverse_of: :supplier,
                class_name: "MyApplication::Billing::Account"
            end

            class Account < ApplicationRecord
              belongs_to :supplier, inverse_of: :account,
                class_name: "MyApplication::Business::Supplier"
            end

            3.3.0 :041 > supplier = MyApplication::Business::Supplier.new(name: "Vaibhav")
            => #<MyApplication::Business::Supplier:0x0000000122773878 id: nil, name: "Vaibhav", created_at: nil, updated_at: nil> 
           3.3.0 :044 > supplier.save!
             TRANSACTION (0.4ms)  BEGIN
             MyApplication::Business::Supplier Create (4.2ms)  INSERT INTO "suppliers" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"  [["name", "Vaibhav"], ["created_at", "2024-07-26 07:26:37.973560"], ["updated_at", "2024-07-26 07:26:37.973560"]]
             MyApplication::Billing::Account Load (0.4ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."supplier_id" = $1 LIMIT $2  [["supplier_id", 4], ["LIMIT", 1]]
             TRANSACTION (0.8ms)  COMMIT
            => true 
           3.3.0 :045 > account = supplier.create_account(account_number: "1234567890")
             TRANSACTION (0.4ms)  BEGIN
             MyApplication::Billing::Account Create (1.9ms)  INSERT INTO "accounts" ("supplier_id", "account_number", "created_at", "updated_at", "accountable_type", "accountable_id") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"  [["supplier_id", 4], ["account_number", "1234567890"], ["created_at", "2024-07-26 07:26:49.833961"], ["updated_at", "2024-07-26 07:26:49.833961"], ["accountable_type", nil], ["accountable_id", nil]]
             TRANSACTION (1.0ms)  COMMIT
            => 
           #<MyApplication::Billing::Account:0x0000000120be9d78
           ... 
           3.3.0 :046 > puts account.supplier == supplier 
           true
            => nil
        
      * :primary_key -> 
        Specifies a custom primary key for the association.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, primary_key: "custom_id",
                class_name: "MyApplication::Billing::Account"
            end
        
      * :query_constraints -> 
        Specifies constraints to be applied when querying the association.
          Example:  
            class Supplier < ApplicationRecord
              has_one :account, query_constraints: ->(relation) { relation.where("accounts.active = ?", true) },
                class_name: "MyApplication::Billing::Account"
            end

      * :required -> 
        Specifies whether the associated record must be present
          Example;
            class Supplier < ApplicationRecord
              has_one :account, required: true,
                class_name: "MyApplication::Billing::Account"
            end

      * :source -> 
        Specifies the source association when using :through.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, through: :supplier_accounts, source: :account
                class_name: "MyApplication::Billing::Account"
            end

      * :source_type -> 
        Specifies the source type for polymorphic associations
          Example:
            class Supplier < ApplicationRecord
              has_one :comment, as: :commentable, source_type: "Supplier"
            end

      * :strict_loading ->
        Ensures that the association is loaded eagerly to avoid potential N+1 query issues.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, strict_loading: true,
                class_name: "MyApplication::Billing::Account"
            end
            3.3.0 :077 > supplier = MyApplication::Business::Supplier.find_by(name: "Naman dua")
             MyApplication::Business::Supplier Load (0.2ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."name" = $1 LIMIT $2  [["name", "Naman dua"], ["LIMIT", 1]]
            => 
           #<MyApplication::Business::Supplier:0x00000001227f86b8
           ... 
           3.3.0 :078 > supplier.account
           (irb):78:in `<main>': `MyApplication::Business::Supplier` is marked for strict_loading. The MyApplication::Billing::Account association named `:account` cannot be lazily loaded. (ActiveRecord::StrictLoadingViolationError)
           3.3.0 :079 > supplier = MyApplication::Business::Supplier.includes(:account).find_by(name: "Naman dua")
           3.3.0 :080 > supplier.account
           3.3.0 :081 > 
             MyApplication::Business::Supplier Load (0.6ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."name" = $1 LIMIT $2  [["name", "Naman dua"], ["LIMIT", 1]]
             MyApplication::Billing::Account Load (0.3ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."supplier_id" = $1  [["supplier_id", 2]]
            => 
           #<MyApplication::Billing::Account:0x0000000120ca5dc0
            id: 2,
            supplier_id: 2,
            account_number: "624752869698",
            created_at: Fri, 26 Jul 2024 06:00:54.575831000 UTC +00:00,
            updated_at: Fri, 26 Jul 2024 06:00:54.575831000 UTC +00:00,
            accountable_type: nil,
            accountable_id: nil> 
           3.3.0 :082 > 

      * :through ->   
        Specifies an intermediate association to set up the has_one :through relationship.
          Example;
            class Supplier < ApplicationRecord
              has_one :account, through: :supplier_account,
                class_name: "MyApplication::Billing::Account"
            end

      * :touch -> 
        Updates the timestamp on the parent record when the associated record is updated.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, touch: true,
                class_name: "MyApplication::Billing::Account"
            end
          3.3.0 :088 > supplier = MyApplication::Business::Supplier.find_by(name: "Naman dua")
             MyApplication::Business::Supplier Load (0.5ms)  SELECT "suppliers".* FROM "suppliers" WHERE "suppliers"."name" = $1 LIMIT $2  [["name", "Naman dua"], ["LIMIT", 1]]
            => 
           #<MyApplication::Business::Supplier:0x0000000122b15350
           ... 
           3.3.0 :089 > supplier.updated_at
            => Fri, 26 Jul 2024 06:00:54.564481000 UTC +00:00            

      * :validate -> 
        Specifies whether the associated record should be validated before saving.
          Example:
            class Supplier < ApplicationRecord
              has_one :account, validate: true,
                class_name: "MyApplication::Billing::Account"
            end


    c) Scopes for has_one
        There may be times when you wish to customize the query used by has_one. Such customizations can be achieved via a scope block. 
          For example:  
            class Supplier < ApplicationRecord
              has_one :account, -> { where active: true }
            end

        You can use any of the standard querying methods inside the scope block.
          * where -> 
            The where method lets you specify the conditions that the associated object must meet.

          * includes -> 
            We can use the includes method to specify second-order associations that should be eager-loaded when this association is used
              Example:
                class Supplier < ApplicationRecord
                  has_one :account, -> { includes :representative }
                end
                class Account < ApplicationRecord
                  belongs_to :supplier
                  belongs_to :representative
                end
                class Representative < ApplicationRecord
                  has_many :accounts
                end

          * readonly -> 
            If we use the readonly method, then the associated object will be read-only when retrieved via the association.

          * select ->
            The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns
