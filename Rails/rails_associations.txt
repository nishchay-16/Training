                                                    RAILS ASSOCIATIONS

An association is a connection between two Active Record models. 
We need associations between models Because they make common operations simpler and easier in your code.
These associations help in organizing and querying related data efficiently. 

For example, consider a simple Rails application that includes a model for authors and a model for books. Each author can have many books.
With Active Record associations, we can streamline these - and other - operations by declaratively telling Rails that there is a connection between the two models. 
Here's the code for setting up authors and books:

class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end



Here are the key advantages of using associations in Rails:
1) Simplified Data Retrieval:->
    Associations provide methods to easily retrieve related records. For example, with has_many and belongs_to, you can access related objects directly without complex queries.

2) Automatic Joins and Queries:->
    Rails handles database joins and complex queries automatically, saving you from writing raw SQL and ensuring efficient data retrieval.

3) Data Integrity:->
    Associations help maintain data integrity by setting constraints and automatic actions (e.g., dependent: :destroy) that ensure related records are handled properly when a parent record is modified or deleted.

4) Enhanced Readability:->
    Code that uses associations is often more readable and expressive. The relationships between models are clear, making the code easier to understand and maintain.

5) Reduced Boilerplate Code:->
    Associations reduce the amount of boilerplate code needed for managing relationships and performing common operations, leading to cleaner and more concise code.

6) Automatic Foreign Key Management:->
    Rails manages foreign keys and validates relationships, helping to avoid issues related to orphaned records or incorrect foreign key values.

7) Convenient Query Methods:->
    Associations provide built-in query methods that simplify searching and filtering related data, such as where, joins, and includes.

8) Support for Nested Attributes:->
    Associations enable nested attributes, allowing you to create or update associated records in a single operation, which is useful for forms with multiple models.

9) Data Caching:->
    Rails can cache associated records to improve performance, especially when using methods like includes to eager-load related records.

10) Validation Integration:->
    Associations can be used in conjunction with validations to enforce rules about relationships, ensuring that related records are present and valid.




                                                ===> TYPES OF ASSOCIATIONS <===

1) belongs_to -> 
A belongs_to association sets up a connection with another model, such that each instance of the declaring model "belongs to" one instance of the other model. 

Example:
class Book < ApplicationRecord
  belongs_to :author
end


2) has_one -> 
A has_one association indicates that one other model has a reference to this model. That model can be fetched through this association.

Example:
class User < ApplicationRecord
  has_one :account
end


3) has_many -> 
A has_many association is similar to has_one, but indicates a one-to-many connection with another model
This association indicates that each instance of the model has zero or more instances of another model. 

Example:
class Author < ApplicationRecord
  has_many :books
end


4) has_many :through -> 
A has_many :through association is often used to set up a many-to-many connection with another model. 
This association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model. 

Example:
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end


5) has_one :through -> 
A has_one :through association sets up a one-to-one connection with another model. 
This association indicates that the declaring model can be matched with one instance of another model by proceeding through a third model.

Example:
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end


6) has_and_belongs_to_many ->
A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model. 
This association indicates that each instance of the declaring model refers to zero or more instances of another model.

Example:
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end




                                ====>     TIPS , TRICKS & WARNINGS (for effecient use of association in rails)    <====

1) Controlling caching ->
All of the association methods are built around caching, which keeps the result of the most recent query available for further operations. 
The cache is even shared across methods:-

author.books.load                  # retrieves books from the database
author.books.size                  # uses the cached copy of books
author.books.empty?                # uses the cached copy of books
author.books.reload.empty?         # discards the cached copy of books and goes back to the database


2) Avoiding name collisions -> 
We are not free to use just any name for your associations. 
Because creating an association adds a method with that name to the model, it is a bad idea to give an association a name that is already used for an instance method of ActiveRecord::Base. 
The association method would override the base method and break things. 
For instance, attributes or connection are bad names for associations.


3) Updating the schema ->
Associations are extremely useful, but they are not magic. You are responsible for maintaining your database schema to match your associations.
   -> Creating Foreign Keys for belongs_to Associations
        class Book < ApplicationRecord
          belongs_to :author
        end

        class AddAuthorToBooks < ActiveRecord::Migration[7.1]
          def change
            add_reference :books, :author
          end
        end

   -> Creating Join Tables for has_and_belongs_to_many Associations
        class Assembly < ApplicationRecord
          has_and_belongs_to_many :parts
        end

        class Part < ApplicationRecord
          has_and_belongs_to_many :assemblies
        end

        class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.1]
          def change
            create_join_table :assemblies, :parts do |t|
              t.index :assembly_id
              t.index :part_id
            end
          end
        end


4) Controlling association scope ->
By default, associations look for objects only within the current module's scope. 
This can be important when you declare Active Record models within a module. 
For example:
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end


5) Bi-directional associations ->
It's normal for associations to work in two directions, requiring declaration on two different models:
Example:
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
Active Record will attempt to automatically identify that these two models share a bi-directional association based on the association name.


IMPORTANT => For belongs_to associations you need to create foreign keys, and for has_and_belongs_to_many associations you need to create the appropriate join table.




                                      ====> Detailed Association Reference <====

1) belongs_to Association Reference ->                    

    a) Methods Added by belongs_to ->

          * association ->
            The association method returns the associated object, if any. If no associated object is found, it returns nil.
                Example:
                  3.3.0 :031 > author = book.author
                  Author Load (0.4ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 10], ["LIMIT", 1]]
                  => 
                  #<Author:0x0000000128fd3ad0

                  3.3.0 :037 > author = book.reload_author
                  Author Load (0.8ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 10], ["LIMIT", 1]]
                  => 
                  #<Author:0x0000000128fd8350

                  3.3.0 :041 > book.reset_author
                  => false 

          * association=(associate) ->
            The association= method assigns an associated object to this object. 
            Behind the scenes, this means extracting the primary key from the associated object and setting this object's foreign key to the same value.
                Example:
                  3.3.0 :039 > book.author = author
                  => 
                  #<Author:0x0000000128fd8350

          * build_association(attributes = {}) ->
            The build_association method returns a new object of the associated type. 
            This object will be instantiated from the passed attributes, and the link through this object's foreign key will be set, but the associated object will not yet be saved.
                Example:
                  3.3.0 :044 > author =  book.build_author(author_name: "HC Verma" , nationality: "Indian")
                  => #<Author:0x000000011dd1c810 id: nil, author_name: "HC Verma", nationality: "Indian", created_at: nil, updated_at: nil> 

          * create_association(attributes = {}) ->
            The create_association method returns a new object of the associated type. 
            This object will be instantiated from the passed attributes, the link through this object's foreign key will be set, 
            and, once it passes all of the validations specified on the associated model, the associated object will be saved.
                Example:
                  3.3.0 :058 > author =  book.create_author(author_name:"MS chauhan", nationality: "Indian")
                  TRANSACTION (0.6ms)  BEGIN
                  Author Create (3.4ms)  INSERT INTO "authors" ("author_name", "nationality", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["author_name", "MS chauhan"], ["nationality", "Indian"], ["created_at", "2024-07-25 10:23:50.376919"], ["updated_at", "2024-07-25 10:23:50.376919"]]
                  TRANSACTION (0.9ms)  COMMIT
                  => 
                  #<Author:0x000000012c1df790

          * create_association!(attributes = {}) -> 
            Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid.

          * association_changed? -> 
            The association_changed? method returns true if a new associated object has been assigned and the foreign key will be updated in the next save.
                Example:
                  3.3.0 :059 > book.author_changed?
                   => true 
                  3.3.0 :060 > book.save!
                    TRANSACTION (0.2ms)  BEGIN
                    Book Update (4.2ms)  UPDATE "books" SET "updated_at" = $1, "author_id" = $2 WHERE "books"."id" = $3  [["updated_at", "2024-07-25 10:27:46.230403"], ["author_id", 12], ["id", 2]]
                    TRANSACTION (1.5ms)  COMMIT
                   => true 
                  3.3.0 :061 > book.author_changed?
                   => false 

          * association_previously_changed? ->
            The association_previously_changed? method returns true if the previous save updated the association to reference a new associate object.
                Example:
                  3.3.0 :062 > book.author_previously_changed?
                   => true 


    b) Options for belongs_to

          * :autosave ->
            Automatically saves the associated records when the parent record is saved.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, autosave: true
                  end
            If you create or update a Book instance and modify its associated Author, the Author will be saved automatically.

          * :class_name ->
            Specifies the class name of the association, if it is not the default.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :writer, class_name: 'Author'
                  end
            Here, Book belongs to Author, but we use writer as the association name. :class_name tells Rails to use the Author model for this association.

          * :counter_cache ->
             Automatically maintains a count of the number of associated records in the parent record’s table.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, counter_cache: true
                  end
            If you add books_count to the authors table, Rails will keep this count updated whenever books are added or removed.

          * :default ->
            Provides a default value for the association, used when the association is not explicitly set.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, default: -> { Author.first }
                  end
            If no author is specified, Rails will assign the first Author record as the default.

          * :dependent ->
            Specifies what should happen to associated records when the parent record is destroyed.
                Example:
                  class Author < ApplicationRecord
                    has_many :books, dependent: :destroy
                  end
            If an Author is destroyed, all associated Books will also be destroyed.

          * :ensuring_owner_was ->
            Specifies an instance method to be called on the owner. 
            The method must return true in order for the associated records to be deleted in a background job.
            
          * :foreign_key ->
            Specifies the foreign key column in the associated table.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, foreign_key: 'writer_id'
                  end
                  class Author < ApplicationRecord                    
                    has_many :books, foreign_key: 'writer_id'
                  end
            The Book model uses writer_id instead of the default author_id to refer to Author.                    

          * :foreign_type ->
            Used with polymorphic associations to specify the type column.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :owner, polymorphic: true, foreign_type: 'owner_type'
                  end
            Here, owner_type is the column that stores the type of the polymorphic association.                   

          * :primary_key ->
            Specifies the primary key column in the associated table.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, primary_key: 'uuid'
                  end
                  class Author < ApplicationRecord                    
                    self.primary_key = 'uuid'
                  end
            If Author uses uuid as its primary key instead of the default id, this option is used.                    

          * :inverse_of ->
            Specifies the inverse association to avoid redundant database queries and ensure proper object relationships.
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, inverse_of: :books
                  end
                  class Author < ApplicationRecord
                    has_many :books, inverse_of: :author
                  end
              This ensures that Rails correctly handles bi-directional associations.

          * :optional ->
            Allows the association to be optional, meaning the parent record can exist without the associated record
                Example:
                  class Book < ApplicationRecord
                    belongs_to :author, optional: true
                  end
            A Book can be created without specifying an Author.

          * :polymorphic ->
            Allows the association to refer to more than one model type.
                Example:
                  class Comment < ApplicationRecord
                    belongs_to :commentable, polymorphic: true
                  end
                  class Book < ApplicationRecord
                    has_many :comments, as: :commentable
                  end
                  class Author < ApplicationRecord
                    has_many :comments, as: :commentable
                  end
            A Comment can belong to either a Book or an Author.

          * :required ->
             Ensures that the association is required and cannot be nil
                Example:
                  class Book < ApplicationRecord
                      belongs_to :author, required: true
                  end
              A Book must have an associated Author and cannot be saved without one.

          * :strict_loading ->
            Ensures that associated records are always loaded when accessed, helping to prevent N+1 query problems. 
                  Example:
                    class Book < ApplicationRecord
                      belongs_to :author, strict_loading: true
                    end
            When accessing @book.author, Rails will ensure that the author is loaded immediately.

          * :touch ->
            Updates the timestamp of the associated record whenever the parent record is updated.
                  Example:
                    class Book < ApplicationRecord
                      belongs_to :author, touch: true
                    end
            Whenever a Book is updated, the updated_at timestamp of its Author will also be updated.

          * :validate ->
            Specifies whether the associated record should be validated before saving the parent record.
                  Example:
                    class Book < ApplicationRecord
                      belongs_to :author, validate: true
                    end 
            When saving a Book, Rails will also validate the associated Author.


2) has_one Association Reference ->
  The has_one association creates a one-to-one match with another model. 
  In database terms, this association says that the other class contains the foreign key. 
  If this class contains the foreign key, then we should use belongs_to instead.

    a) Methods Added by has_one 

      * association -> 
        The association method returns the associated object, if any. If no associated object is found, it returns nil.
        Example:
          3.3.0 :001 > supplier = MyApplication::Business::Supplier.find_by(id: 1)
          3.3.0 :009 > account = supplier.account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
          ... 
          3.3.0 :010 > account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
           id: 1,
           supplier_id: 1,
           account_number: "1234567890",
           created_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00,
           updated_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00> 

      * association=(associate) -> 
        The association= method assigns an associated object to this object. 
        Behind the scenes, this means extracting the primary key from this object and setting the associated object's foreign key to the same value.
        Example:
          3.3.0 :011 > supplier = MyApplication::Business::Supplier.find_by(id: 1)
          3.3.0 :012 > supplier.account = account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
          ... 
          3.3.0 :013 > account
           => 
          #<MyApplication::Billing::Account:0x000000011e2ea530
           id: 1,
           supplier_id: 1,
           account_number: "1234567890",
           created_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00,
           updated_at: Fri, 26 Jul 2024 05:43:58.867819000 UTC +00:00> 

      * build_association(attributes = {}) -> 
        The build_association method returns a new object of the associated type. 
        This object will be instantiated from the passed attributes, and the link through its foreign key will be set, but the associated object will not yet be saved.
        Example:
          3.3.0 :017 > supplier = MyApplication::Business::Supplier.new(name: "Naman dua")
           => #<MyApplication::Business::Supplier:0x000000011f10ec60 id: nil, name: "Naman dua", created_at: nil, updated_at: nil> 
          3.3.0 :018 > account = supplier.build_account(account_number: "624752869698")
           => #<MyApplication::Billing::Account:0x000000011f0830c0 id: nil, supplier_id: nil, account_number: "624752869698", created_at: nil, updated_at: ... 

      * create_association(attributes = {}) -> 
        The create_association method returns a new object of the associated type. 
        This object will be instantiated from the passed attributes, the link through its foreign key will be set, and, 
        once it passes all of the validations specified on the associated model, the associated object will be saved.
        Example:
         => #<MyApplication::Billing::Account:0x000000011f0830c0 id: nil, supplier_id: nil, account_number: "624752869698", created_at: nil, updated_at: ... 
          3.3.0 :020 > account = supplier.create_account(account_number: "624752869698")
          (irb):20:in `<main>': You cannot call create unless the parent is saved (ActiveRecord::RecordNotSaved)
          3.3.0 :021 > supplier.save!         
            TRANSACTION (0.6ms)  BEGIN
            MyApplication::Business::Supplier Create (7.9ms)  INSERT INTO "suppliers" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"  [["name", "Naman dua"], ["created_at", "2024-07-26 06:00:54.564481"], ["updated_at", "2024-07-26 06:00:54.564481"]]
            MyApplication::Billing::Account Create (1.6ms)  INSERT INTO "accounts" ("supplier_id", "account_number", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["supplier_id", 2], ["account_number", "624752869698"], ["created_at", "2024-07-26 06:00:54.575831"], ["updated_at", "2024-07-26 06:00:54.575831"]]
            TRANSACTION (1.1ms)  COMMIT
           => true 

      * create_association!(attributes = {}) ->
        Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid.

      * reload_association ->
        If the associated object has already been retrieved from the database for this object, the cached version will be returned
        Example:
          3.3.0 :023 > account = supplier.reload_account
           MyApplication::Billing::Account Load (0.6ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."supplier_id" = $1 LIMIT $2  [["supplier_id", 2], ["LIMIT", 1]]
           => 
          #<MyApplication::Billing::Account:0x000000011f0c99d0
          ... 

      * reset_association ->
        To unload the cached version of the associated object—forcing the next access, if any, to query it from the database—call #reset_association on the parent object.
        Example:
          3.3.0 :024 > supplier.reset_account
           => nil

